<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>逆水寒手游｜技能循环排轴工具（初版 v0.14）</title>
  <style>
    :root {
      --bg: #0b0f17;
      --panel2: #0f1623;
      --text: #e6edf7;
      --muted: #a9b4c7;
      --border: #243146;
      --danger: #ff6b6b;
      --ok: #66d9a5;
      --warn: #ffd166;
      --accent: #7aa2ff;
    }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "PingFang SC", "Microsoft YaHei", Arial, sans-serif;
      background: radial-gradient(1200px 700px at 30% 10%, #15243b 0%, var(--bg) 55%);
      color: var(--text);
    }
    .wrap { max-width: 1100px; margin: 24px auto; padding: 0 16px 40px; }
    h1 { font-size: 20px; margin: 0 0 12px; letter-spacing: 0.2px; }
    .sub { color: var(--muted); font-size: 13px; margin-bottom: 18px; line-height: 1.6; }
    .card {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.0));
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 14px;
      box-shadow: 0 12px 28px rgba(0,0,0,0.25);
    }
    .card h2 { font-size: 14px; margin: 0 0 10px; color: #dce6fb; }
    .grid2 { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    @media (max-width: 900px) { .grid2 { grid-template-columns: 1fr; } }
    label { display: block; font-size: 13px; color: var(--muted); margin-bottom: 6px; }
    select, input[type="number"], input[type="text"] {
      width: 100%; box-sizing: border-box; background: var(--panel2);
      border: 1px solid var(--border); color: var(--text);
      border-radius: 10px; padding: 10px 10px; outline: none;
    }
    input[type="text"]::placeholder { color: #6f7f9c; }
    .btns { display: flex; gap: 10px; flex-wrap: wrap; margin-top: 12px; }
    button {
      background: var(--panel2); border: 1px solid var(--border); color: var(--text);
      border-radius: 12px; padding: 10px 12px; cursor: pointer; font-size: 13px;
    }
    button.primary { border-color: rgba(122,162,255,0.55); background: rgba(122,162,255,0.12); }
    button.danger { border-color: rgba(255,107,107,0.55); background: rgba(255,107,107,0.12); }
    button:disabled { opacity: 0.55; cursor: not-allowed; }
    .stepper { display: flex; gap: 8px; flex-wrap: wrap; margin: 12px 0 14px; }
    .pill {
      font-size: 12px; border: 1px solid var(--border); background: rgba(255,255,255,0.02);
      border-radius: 999px; padding: 6px 10px; color: var(--muted);
    }
    .pill.active { border-color: rgba(122,162,255,0.6); color: var(--text); }
    .warn {
      border-left: 4px solid var(--danger); background: rgba(255,107,107,0.12);
      padding: 10px 12px; border-radius: 10px; color: #ffd9d9;
      font-size: 13px; line-height: 1.6;
    }
    .hint {
      border-left: 4px solid var(--warn); background: rgba(255,209,102,0.12);
      padding: 10px 12px; border-radius: 10px; color: #ffecc2;
      font-size: 13px; line-height: 1.6;
    }
    .ok {
      border-left: 4px solid var(--ok); background: rgba(102,217,165,0.12);
      padding: 10px 12px; border-radius: 10px; color: #d6ffee;
      font-size: 13px; line-height: 1.6;
    }
    .section { border: 1px solid var(--border); border-radius: 12px; padding: 10px; background: rgba(255,255,255,0.02); }
    .section h3 { margin: 0 0 8px; font-size: 13px; color: #dce6fb; }
    .subsec { border: 1px dashed rgba(169,180,199,0.35); border-radius: 12px; padding: 10px; background: rgba(255,255,255,0.01); }
    .subsec h4 { margin: 0 0 8px; font-size: 13px; color: #dce6fb; }
    .radioRow { display: flex; gap: 14px; flex-wrap: wrap; align-items: center; }
    .radioRow label { margin: 0; color: var(--text); display: inline-flex; gap: 8px; align-items: center; font-size: 13px; }
    .radioRow input { transform: scale(1.05); }
    .skill-grid { display: grid; grid-template-columns: 1fr; gap: 12px; }
    .skill-section { border: 1px solid var(--border); border-radius: 12px; padding: 10px; background: rgba(255,255,255,0.02); }
    .skill-section h3 { margin: 0 0 8px; font-size: 13px; color: #dce6fb; }
    .skill-list { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 8px; }
    @media (max-width: 900px) { .skill-list { grid-template-columns: 1fr; } }
    .skill-item { display: flex; gap: 10px; align-items: flex-start; padding: 8px 10px; border: 1px solid var(--border); background: var(--panel2); border-radius: 12px; opacity: 1; }
    .skill-item.disabled { opacity: 0.45; }
    .skill-item small { color: var(--muted); display: block; margin-top: 2px; line-height: 1.35; }
    .skill-item input { margin-top: 2px; transform: scale(1.1); }
    .order-list { display: grid; grid-template-columns: 1fr; gap: 8px; }
    .order-row { display: grid; grid-template-columns: 1.2fr 0.7fr 0.7fr auto; gap: 8px; align-items: center; padding: 10px; background: var(--panel2); border: 1px solid var(--border); border-radius: 12px; }
    @media (max-width: 900px) { .order-row { grid-template-columns: 1fr; } .order-row .miniBtns { justify-content: flex-start; } }
    .badge { display: inline-block; font-size: 11px; padding: 2px 8px; border-radius: 999px; border: 1px solid var(--border); color: var(--muted); margin-left: 8px; }
    .badge.blue { border-color: rgba(122,162,255,0.6); color: #dce6fb; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    table { width: 100%; border-collapse: collapse; font-size: 13px; overflow: hidden; border-radius: 12px; }
    th, td { border-bottom: 1px solid var(--border); padding: 10px 10px; vertical-align: top; }
    th { text-align: left; color: #cfe0ff; background: rgba(255,255,255,0.03); }
    tr.vacuum td { color: #ffd9d9; background: rgba(255,107,107,0.10); }
    tr.vacuum.death td { color: #ffe6e6; background: rgba(255, 60, 60, 0.22); border-bottom-color: rgba(255, 80, 80, 0.55); }
    tr.vacuum.death td:first-child { box-shadow: inset 4px 0 0 rgba(255, 60, 60, 0.85); }
    tr.skip td { color: #ffecc2; background: rgba(255,209,102,0.10); }
    .muted { color: var(--muted); }
    .hidden { display: none; }
    .footerNote { margin-top: 16px; color: var(--muted); font-size: 12px; line-height: 1.6; }
    .kbd {
      display:inline-block; padding: 1px 6px; border: 1px solid var(--border);
      border-radius: 6px; background: rgba(255,255,255,0.02);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12px; color: #dce6fb;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>逆水寒手游｜技能循环排轴工具（初版 v0.14）</h1>
    <div class="sub">
      数据来源：本地 Excel（已内嵌）｜职业：<span class="mono">妙音</span>；通用：<span class="mono">绝技 / 内功 / 百家</span>。<br/>
      口径：霸体为空/≤0按0秒；冷却期间不可再次施放；真空=按当前排轴策略无可施放技能。<br/>
      木周天：仅影响<strong>职业技能</strong>有效冷却；3木特效仅由<strong>非内功</strong>技能施放触发（职业/绝技/百家均可触发），效果仅作用于职业技能冷却。<br/>妙音：<strong>逐月</strong> 与 <strong>逐月·乘风</strong> 为必带技能（解控），默认强制携带。<br/>
      新增：排轴策略（严格/动态）；飞天联动限制；俯仰太虚联动限制；莲步盈华互斥选择。
    </div>

    <div class="stepper">
      <span id="pill1" class="pill active">1. 选择模式</span>
      <span id="pill2" class="pill">2. 选择职业</span>
      <span id="pill3" class="pill">3. 选择技能</span>
      <span id="pill4" class="pill">4. 排序</span>
      <span id="pill5" class="pill">5. 结果</span>
    </div>

    <div id="step1" class="card">
      <h2>Step 1｜选择游戏模式</h2>
      <div class="grid2">
        <div>
          <label>游戏模式</label>
          <select id="modeSelect"></select>
        </div>
        <div>
          <label>模式时长（秒）</label>
          <input id="modeDuration" type="number" min="1" step="1" />
          <div class="muted" style="margin-top:6px; font-size:12px;">
            默认：公平论武=120s；比武大会=180s。可手动覆盖。
          </div>
        </div>
      </div>

      <div style="margin-top:10px;">
        <label>真空死亡阈值（秒）</label>
        <input id="deathThreshold" type="number" min="0" step="0.1" value="3.0" />
        <div class="muted" style="margin-top:6px; font-size:12px;">
          单段真空持续时间 ≥ 该值即判定为“死亡真空”。设为 <span class="mono">0</span> 表示不启用。
        </div>
      </div>

      <div class="btns">
        <button class="primary" id="toStep2">下一步</button>
      </div>
    </div>

    <div id="step2" class="card hidden">
      <h2>Step 2｜选择职业（流派）</h2>
      <div class="grid2">
        <div>
          <label>职业</label>
          <select id="profSelect"></select>
        </div>
        <div>
          <label>说明</label>
          <div class="hint">
            - 霸体为空/≤0：视为 <span class="mono">0s</span><br/>
            - “动态排轴”：在无技能释放的时间点，会优先按顺序找可释放技能填充真空；“严格排轴”：只等当前轮到的技能（但遇到前置条件不满足会跳过）
          </div>
        </div>
      </div>
      <div class="btns">
        <button id="back1">上一步</button>
        <button class="primary" id="toStep3">下一步</button>
      </div>
    </div>

    <div id="step3" class="card hidden">
      <h2>Step 3｜选择你携带的技能</h2>

      <div class="section" style="margin-bottom:12px;">
        <h3>其他</h3>
        <div class="subsec">
          <h4>木周天</h4>
          <div class="radioRow">
            <label><input type="radio" name="wood" value="0" checked> 不选择（无影响）</label>
            <label><input type="radio" name="wood" value="1"> 1木（职业技能冷却 -3%）</label>
            <label><input type="radio" name="wood" value="2"> 2木（职业技能冷却 -4%）</label>
            <label><input type="radio" name="wood" value="3"> 3木（职业技能冷却 -5% + 特效）</label>
          </div>
          <div class="muted" style="margin-top:8px; font-size:12px; line-height:1.6;">
            3木特效口径：当“至少有 3 个职业技能处于冷却中”时，下一次施放<strong>非内功</strong>技能将使所有处于冷却状态的职业技能：剩余冷却降低40%，单技能最多减少5秒；该特效自身冷却20秒。
          </div>
        </div>
      </div>

      <div class="grid2">
        <div>
          <label>技能搜索（按名称）</label>
          <input id="skillSearch" type="text" placeholder="输入关键字过滤（例如：飞天 / 莲心 / 逐月）" />
        </div>
        <div>
          <label>快速操作</label>
          <div class="btns" style="margin-top:0;">
            <button id="selectAll">全选当前过滤结果</button>
            <button class="danger" id="clearAll">清空全部选择</button>
          </div>
        </div>
      </div>

      <div id="hintMissingCast" class="hint hidden" style="margin-top:12px;"></div>
      <div id="hintMissingCd" class="hint hidden" style="margin-top:12px;"></div>
      <div id="hintExclusives" class="hint" style="margin-top:12px;">
        互斥提示：<span class="mono">莲步盈华</span> 与 <span class="mono">莲步盈华·并蒂</span> 只能同时携带一个；<span class="mono">俯仰太虚</span> 与 <span class="mono">俯仰太虚·灵韵</span> 互斥；<span class="mono">纳百观</span> 与 <span class="mono">纳百观·灵韵</span> 互斥。<br/>妙音必带：<span class="mono">逐月</span>、<span class="mono">逐月·乘风</span>（解控，不可取消）。
      </div>

      <div id="skillContainer" class="skill-grid" style="margin-top:12px;"></div>

      <div class="btns">
        <button id="back2">上一步</button>
        <button class="primary" id="toStep4">下一步（去排序）</button>
      </div>
    </div>

    <div id="step4" class="card hidden">
      <h2>Step 4｜手动排列技能顺序</h2>

      <div class="section" style="margin-bottom:12px;">
        <h3>排轴策略</h3>
        <div class="radioRow">
          <label><input type="radio" name="sched" value="strict" checked> 严格排轴（固定顺序；冷却未好则等待；前置条件不满足则跳过）</label>
          <label><input type="radio" name="sched" value="dynamic"> 动态排轴（无技能释放时，按顺序优先释放已转好技能填充真空）</label>
        </div>
        <div class="muted" style="margin-top:8px; font-size:12px; line-height:1.6;">
          动态排轴的优先级：从“当前排轴指针”开始，按你设置的顺序循环扫描，找到第一个“冷却已好 + 前置条件满足”的技能即释放。
        </div>
      </div>

      <div class="muted" style="margin-bottom:10px; font-size:12px;">
        支持拖拽排序；也可用 <span class="kbd">↑</span>/<span class="kbd">↓</span> 微调。
      </div>

      <div id="orderEmpty" class="warn hidden">你还没有选择任何技能。请返回上一步选择技能。</div>

      <div id="orderList" class="order-list"></div>

      <div class="btns">
        <button id="back3">上一步</button>
        <button class="primary" id="calc">生成排轴</button>
      </div>
    </div>

    <div id="step5" class="card hidden">
      <h2>Step 5｜排轴结果</h2>

      <div id="summaryBox" class="ok" style="margin-bottom:12px;"></div>

      <div class="btns" style="margin-top:0; margin-bottom:12px;">
        <label style="display:inline-flex;align-items:center;gap:8px; padding: 8px 10px; border:1px solid var(--border); border-radius:12px; background: rgba(255,255,255,0.02);">
          <input id="filterNoCast" type="checkbox" style="transform:scale(1.1);" />
          <span>隐藏无霸体时间技能（霸体=0）</span>
        </label>

        <button id="copyText">复制文本结果</button>
        <button id="exportCsv">导出 CSV</button>
        <button id="restart">重新开始</button>
      </div>

      <div style="overflow:auto; border:1px solid var(--border); border-radius:12px;">
        <table id="resultTable">
          <thead>
            <tr>
              <th style="width:120px;">起始时间</th>
              <th style="width:120px;">结束时间</th>
              <th>动作</th>
              <th style="width:140px;">来源</th>
              <th style="width:140px;">霸体/占用</th>
              <th style="width:140px;">冷却（有效）</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>

      <div class="footerNote">
        备注：当前只实现了少量“前置条件”规则（飞天/莲心/逐月/俯仰太虚）以及莲步互斥；其它连携/层数/资源未纳入。
      </div>
    </div>
  </div>

<script>
const DB = {"meta": {"generated_at": "2026-02-13T02:40:59", "source_file": "逆水寒数据.xlsx", "universal_sheets": ["绝技", "内功", "百家"], "profession_sheets": ["妙音"]}, "modes": [{"id": "fair", "name": "公平论武", "duration": 120}, {"id": "tournament", "name": "比武大会", "duration": 180}], "skills": {"profession": {"妙音": [{"name": "飞泉", "cd": 7.0, "cast": null, "duration": null, "dmg_reduction": null, "note": null}, {"name": "九霄落影", "cd": 20.0, "cast": 1.7, "duration": 6.0, "dmg_reduction": null, "note": null}, {"name": "水月吟", "cd": 10.0, "cast": null, "duration": null, "dmg_reduction": null, "note": null}, {"name": "塞上曲", "cd": 14.0, "cast": null, "duration": 12.0, "dmg_reduction": null, "note": null}, {"name": "春霖", "cd": 16.0, "cast": null, "duration": 30.0, "dmg_reduction": null, "note": null}, {"name": "祈愿", "cd": 35.0, "cast": 4.5, "duration": 3.5, "dmg_reduction": 35.0, "note": null}, {"name": "比翼连枝", "cd": 30.0, "cast": null, "duration": 240.0, "dmg_reduction": null, "note": null}, {"name": "逐月", "cd": 18.0, "cast": 2.0, "duration": 2.0, "dmg_reduction": 25.0, "note": null}, {"name": "逐月·乘风", "cd": null, "cast": 1.5, "duration": 1.5, "dmg_reduction": null, "note": null}, {"name": "飞天", "cd": 45.0, "cast": 4.0, "duration": 20.0, "dmg_reduction": 25.0, "note": null}, {"name": "飞天·莲心", "cd": null, "cast": 1.0, "duration": 1.0, "dmg_reduction": 25.0, "note": null}, {"name": "莲步盈华", "cd": 90.0, "cast": 12.0, "duration": 12.0, "dmg_reduction": 100.0, "note": null}, {"name": "莲步盈华·并蒂", "cd": 60.0, "cast": 12.0, "duration": 12.0, "dmg_reduction": 100.0, "note": null}]}, "universal": {"绝技": [{"name": "净世莲华", "cd": 50, "cast": 4, "duration": 18, "dmg_reduction": null, "note": null}], "内功": [{"name": "不动明王·灵韵", "cd": 35, "cast": 2.0, "duration": 2, "dmg_reduction": 30, "note": null}, {"name": "俯仰太虚", "cd": 12, "cast": null, "duration": 3, "dmg_reduction": 15, "note": "减少流派解控技能冷却3秒"}, {"name": "俯仰太虚·灵韵", "cd": 12, "cast": null, "duration": 4, "dmg_reduction": 15, "note": "减少流派解控技能冷却4秒"}, {"name": "纳百观", "cd": 8, "cast": null, "duration": 6, "dmg_reduction": 4, "note": null}, {"name": "纳百观·灵韵", "cd": 8, "cast": null, "duration": 6, "dmg_reduction": 5, "note": null}], "百家": [{"name": "揽雀尾", "cd": 13, "cast": 3.5, "duration": 4, "dmg_reduction": 60.0, "note": null}, {"name": "凤绽朱华", "cd": 15, "cast": 1.25, "duration": 4, "dmg_reduction": null, "note": null}]}}};
const $ = (id) => document.getElementById(id);

function fmt(t) {
  const s = (Math.round(t*100)/100).toFixed(2);
  return s.endsWith(".00") ? s.slice(0,-3) : s.replace(/0$/, "");
}

function setActiveStep(n) {
  for (let i=1;i<=5;i++) {
    $("pill"+i).classList.toggle("active", i===n);
    $("step"+i).classList.toggle("hidden", i!==n);
  }
}

function keyOf(source, name) { return source + "::" + name; }

function buildSkillIndex(profName) {
  const index = new Map();
  const profSkills = (DB.skills.profession[profName] || []).map(s => ({...s, source: profName}));
  const uni = [];
  for (const cat of Object.keys(DB.skills.universal)) {
    for (const s of DB.skills.universal[cat] || []) uni.push({...s, source: cat});
  }
  for (const s of [...profSkills, ...uni]) {
    const k = keyOf(s.source, s.name);
    index.set(k, {...s, key: k});
  }
  return index;
}

function getWoodChoice() {
  const checked = document.querySelector('input[name="wood"]:checked');
  return checked ? Number(checked.value) : 0;
}

function woodCdMultiplier(choice) {
  if (choice === 1) return 0.97;
  if (choice === 2) return 0.96;
  if (choice === 3) return 0.95;
  return 1.0;
}

function effectiveCd(skill, profName, woodChoice) {
  const base = Number(skill.cd ?? 0);
  if (skill.source === profName) return base * woodCdMultiplier(woodChoice);
  return base;
}

function getSchedMode() {
  const checked = document.querySelector('input[name="sched"]:checked');
  return checked ? checked.value : "strict";
}

function renderModeOptions() {
  const sel = $("modeSelect");
  sel.innerHTML = "";
  for (const m of DB.modes) {
    const opt = document.createElement("option");
    opt.value = m.id;
    opt.textContent = m.name + "（" + m.duration + "s）";
    sel.appendChild(opt);
  }
  sel.addEventListener("change", () => {
    const m = DB.modes.find(x=>x.id===sel.value);
    $("modeDuration").value = m ? m.duration : 120;
  });
  sel.value = DB.modes[0].id;
  $("modeDuration").value = DB.modes[0].duration;
}

function renderProfOptions() {
  const sel = $("profSelect");
  sel.innerHTML = "";
  for (const p of DB.meta.profession_sheets) {
    const opt = document.createElement("option");
    opt.value = p;
    opt.textContent = p;
    sel.appendChild(opt);
  }
  sel.value = DB.meta.profession_sheets[0] || "";
}

let state = {
  modeId: DB.modes[0].id,
  modeDuration: DB.modes[0].duration,
  deathThreshold: 3.0,
  prof: DB.meta.profession_sheets[0] || "",
  woodChoice: 0,
  schedMode: "strict",
  skillIndex: new Map(),
  selectedKeys: new Set(),
  orderedKeys: [],
  events: []
};

function getKeysByNameExact(name) {
  const out = [];
  for (const s of state.skillIndex.values()) {
    if (s.name === name) out.push(s.key);
  }
  return out;
}

function getKeysByNameAndSource(name, source) {
  const out = [];
  for (const s of state.skillIndex.values()) {
    if (s.name === name && s.source === source) out.push(s.key);
  }
  return out;
}
function isMiaoyinRequiredSkill(s) {
  if (!(state.prof === "妙音" && s.source === state.prof)) return false;
  const nm = s.name;
  if (nm === "逐月") return true;
  if (nm === "飞天") return true;
  if (nm === "逐月·乘风" || nm === "逐月乘风" || nm === "逐月.乘风" || nm === "逐月 乘风") return true;
  if (nm === "飞天·莲心" || nm === "飞天莲心" || nm === "飞天.莲心" || nm === "飞天 莲心") return true;
  return false;
}
function enforceRequiredSkills() {
  if (state.prof !== "妙音") return;
  // 妙音必带解控/关键技能：逐月、逐月·乘风、飞天、飞天·莲心（兼容若干写法；若数据表尚未包含则不报错）
  const needs = [
    {alts:["逐月"]},
    {alts:["逐月·乘风","逐月乘风","逐月.乘风","逐月 乘风"]},
    {alts:["飞天"]},
    {alts:["飞天·莲心","飞天莲心","飞天.莲心","飞天 莲心"]}
  ];
  for (const item of needs) {
    for (const nm of item.alts) {
      const ks = getKeysByNameAndSource(nm, state.prof);
      if (ks.length) {
        for (const k of ks) state.selectedKeys.add(k);
        break;
      }
    }
  }
}

function enforceMutualExclusion() {
  // 互斥规则：若同时选中，默认优先保留前者（A），取消后者（B）
  const rules = [
    {a:"莲步盈华", b:"莲步盈华·并蒂", source:null},         // 不限定来源
    {a:"俯仰太虚", b:"俯仰太虚·灵韵", source:"内功"},       // 仅内功表互斥
    {a:"纳百观", b:"纳百观·灵韵", source:"内功"}            // 仅内功表互斥
  ];
  for (const r of rules) {
    const aKeys = (r.source ? getKeysByNameAndSource(r.a, r.source) : getKeysByNameExact(r.a));
    const bKeys = (r.source ? getKeysByNameAndSource(r.b, r.source) : getKeysByNameExact(r.b));
    const aSelected = aKeys.some(k=>state.selectedKeys.has(k));
    const bSelected = bKeys.some(k=>state.selectedKeys.has(k));
    if (aSelected && bSelected) {
      for (const k of bKeys) state.selectedKeys.delete(k);
    }
  }
}

function applyExclusiveOnSelect(skill) {
  // 当勾选某项时，自动取消其互斥项（按“当前勾选优先”的口径）
  const rules = [
    {a:"莲步盈华", b:"莲步盈华·并蒂", source:null},
    {a:"俯仰太虚", b:"俯仰太虚·灵韵", source:"内功"},
    {a:"纳百观", b:"纳百观·灵韵", source:"内功"}
  ];
  for (const r of rules) {
    const matchSource = (r.source === null) || (skill.source === r.source);
    if (!matchSource) continue;
    if (skill.name === r.a) {
      const bKeys = (r.source ? getKeysByNameAndSource(r.b, r.source) : getKeysByNameExact(r.b));
      for (const k of bKeys) state.selectedKeys.delete(k);
    } else if (skill.name === r.b) {
      const aKeys = (r.source ? getKeysByNameAndSource(r.a, r.source) : getKeysByNameExact(r.a));
      for (const k of aKeys) state.selectedKeys.delete(k);
    }
  }
}

function renderSkillPicker() {
  const prof = state.prof;
  state.skillIndex = buildSkillIndex(prof);

  // 妙音必带：逐月、逐月·乘风
  enforceRequiredSkills();

  const container = $("skillContainer");
  container.innerHTML = "";

  const search = ($("skillSearch").value || "").trim().toLowerCase();
  const wood = state.woodChoice;

  const grouped = new Map();
  for (const s of state.skillIndex.values()) {
    if (search && !s.name.toLowerCase().includes(search)) continue;
    if (!grouped.has(s.source)) grouped.set(s.source, []);
    grouped.get(s.source).push(s);
  }

  const missCast = [];
  const missCd = [];
  for (const [src, arr] of grouped.entries()) {
    for (const s of arr) {
      const cast = s.cast;
      const cd = s.cd;
      if (cast === null || cast === undefined || !(cast > 0)) missCast.push(`${s.name}（来源：${src}）`);
      if (cd === null || cd === undefined) missCd.push(`${s.name}（来源：${src}）`);
    }
  }

  const castBox = $("hintMissingCast");
  if (missCast.length > 0) {
    castBox.classList.remove("hidden");
    castBox.innerHTML = `以下技能“霸体时间”为空或≤0（当前按 <span class="mono">0 秒</span> 处理）：<br/>` +
      `<span class="mono">${missCast.slice(0, 18).join("、")}${missCast.length>18 ? " …" : ""}</span>`;
  } else { castBox.classList.add("hidden"); castBox.innerHTML = ""; }

  const cdBox = $("hintMissingCd");
  if (missCd.length > 0) {
    cdBox.classList.remove("hidden");
    cdBox.innerHTML = `以下技能“冷却时间”为空（当前按 <span class="mono">0 秒</span> 处理，可能导致排轴不符合实战，请补齐冷却数据）：<br/>` +
      `<span class="mono">${missCd.slice(0, 18).join("、")}${missCd.length>18 ? " …" : ""}</span>`;
  } else { cdBox.classList.add("hidden"); cdBox.innerHTML = ""; }

  if (grouped.size === 0) {
    const empty = document.createElement("div");
    empty.className = "warn";
    empty.textContent = "没有匹配到技能（请清空搜索关键词或检查数据）。";
    container.appendChild(empty);
    return;
  }

  enforceMutualExclusion();

  for (const [src, arr] of grouped.entries()) {
    arr.sort((a,b)=>a.name.localeCompare(b.name, "zh-CN"));
    const sec = document.createElement("div");
    sec.className = "skill-section";
    const title = document.createElement("h3");
    title.textContent = (src === prof ? `职业：${src}` : `通用：${src}`) + `（${arr.length}）`;
    sec.appendChild(title);

    const list = document.createElement("div");
    list.className = "skill-list";

    for (const s of arr) {
      const item = document.createElement("div");
      item.className = "skill-item";

      const cast = (s.cast ?? 0);
      const effCd = effectiveCd(s, prof, wood);
      const willLoopTrap = (! (cast > 0)) && (! (effCd > 0));
      if (willLoopTrap) item.classList.add("disabled");

      const cb = document.createElement("input");
      cb.type = "checkbox";
      const required = isMiaoyinRequiredSkill(s);
      if (required) state.selectedKeys.add(s.key);
      cb.checked = state.selectedKeys.has(s.key);
      cb.disabled = willLoopTrap || required;
      if (required) cb.title = "妙音必带解控：逐月/逐月·乘风（不可取消）";
      cb.addEventListener("change", () => {
        if (cb.checked) {
          state.selectedKeys.add(s.key);
          applyExclusiveOnSelect(s);
        } else {
          state.selectedKeys.delete(s.key);
        }
        renderSkillPicker();
      });

      const meta = document.createElement("div");
      const name = document.createElement("div");
      name.innerHTML = `<span>${s.name}</span><span class="badge">${src}</span>`;
      const info = document.createElement("small");

      const baseCd = Number(s.cd ?? 0);
      const cdText = (src === prof && wood !== 0)
        ? `冷却：<span class="mono">${fmt(baseCd)}</span>s → <span class="mono">${fmt(effCd)}</span>s`
        : `冷却：<span class="mono">${fmt(baseCd)}</span>s`;

      const extra = (s.source === "内功") ? ` ｜ <span class="muted">内功：不触发3木特效</span>` : "";

      info.innerHTML = `${cdText} ｜ 霸体：<span class="mono">${(cast>0)?cast:0}</span>s` +
        (willLoopTrap ? ` ｜ <span style="color:#ffd9d9;">不可选：0有效CD+0霸体会死循环</span>` : "") +
        extra +
        (s.note ? ` ｜ 备注：${String(s.note)}` : "");

      meta.appendChild(name);
      meta.appendChild(info);

      item.appendChild(cb);
      item.appendChild(meta);
      list.appendChild(item);
    }

    sec.appendChild(list);
    container.appendChild(sec);
  }
}

function collectOrderedFromSelected() {
  const selected = [...state.selectedKeys];
  const existing = state.orderedKeys.filter(k => state.selectedKeys.has(k));
  const existingSet = new Set(existing);
  const newOnes = selected.filter(k => !existingSet.has(k));
  newOnes.sort((ka,kb)=> {
    const a = state.skillIndex.get(ka);
    const b = state.skillIndex.get(kb);
    return (a?.name || "").localeCompare((b?.name || ""), "zh-CN");
  });
  state.orderedKeys = [...existing, ...newOnes];
}

function renderOrderList() {
  const box = $("orderList");
  box.innerHTML = "";
  $("orderEmpty").classList.toggle("hidden", state.orderedKeys.length !== 0);

  const prof = state.prof;
  const wood = state.woodChoice;

  const makeRow = (k, idx) => {
    const s = state.skillIndex.get(k);
    if (!s) return null;
    const row = document.createElement("div");
    row.className = "order-row";
    row.draggable = true;

    row.addEventListener("dragstart", (e)=> {
      e.dataTransfer.setData("text/plain", k);
      e.dataTransfer.effectAllowed = "move";
    });
    row.addEventListener("dragover", (e)=> {
      e.preventDefault();
      e.dataTransfer.dropEffect = "move";
      row.style.borderColor = "rgba(122,162,255,0.8)";
    });
    row.addEventListener("dragleave", ()=> { row.style.borderColor = "var(--border)"; });
    row.addEventListener("drop", (e)=> {
      e.preventDefault();
      row.style.borderColor = "var(--border)";
      const fromKey = e.dataTransfer.getData("text/plain");
      const toKey = k;
      if (!fromKey || fromKey === toKey) return;
      const fromIdx = state.orderedKeys.indexOf(fromKey);
      const toIdx = state.orderedKeys.indexOf(toKey);
      if (fromIdx < 0 || toIdx < 0) return;
      state.orderedKeys.splice(fromIdx, 1);
      state.orderedKeys.splice(toIdx, 0, fromKey);
      renderOrderList();
    });

    const name = document.createElement("div");
    name.innerHTML = `<b>${idx+1}.</b> ${s.name} <span class="badge">${s.source}</span>`;

    const effCd = effectiveCd(s, prof, wood);
    const cd = document.createElement("div");
    cd.className = "mono";
    cd.textContent = fmt(effCd) + "s";

    const cast = document.createElement("div");
    cast.className = "mono";
    cast.textContent = (((s.cast ?? 0) > 0) ? s.cast : 0) + "s";

    const mini = document.createElement("div");
    mini.style.display = "flex";
    mini.style.gap = "6px";
    mini.style.justifyContent = "flex-end";

    const up = document.createElement("button");
    up.textContent = "↑";
    up.disabled = idx === 0;
    up.addEventListener("click", ()=> {
      if (idx===0) return;
      const tmp = state.orderedKeys[idx-1];
      state.orderedKeys[idx-1] = state.orderedKeys[idx];
      state.orderedKeys[idx] = tmp;
      renderOrderList();
    });

    const down = document.createElement("button");
    down.textContent = "↓";
    down.disabled = idx === state.orderedKeys.length - 1;
    down.addEventListener("click", ()=> {
      if (idx>=state.orderedKeys.length-1) return;
      const tmp = state.orderedKeys[idx+1];
      state.orderedKeys[idx+1] = state.orderedKeys[idx];
      state.orderedKeys[idx] = tmp;
      renderOrderList();
    });

    const del = document.createElement("button");
    del.textContent = "移除";
    del.className = "danger";
    const required = isMiaoyinRequiredSkill(s);
    if (required) {
      del.disabled = true;
      del.title = "妙音必带解控：不可移除";
    }
    del.addEventListener("click", ()=> {
      state.selectedKeys.delete(k);
      state.orderedKeys = state.orderedKeys.filter(x=>x!==k);
      renderSkillPicker();
      renderOrderList();
    });

    mini.appendChild(up); mini.appendChild(down); mini.appendChild(del);
    row.appendChild(name); row.appendChild(cd); row.appendChild(cast); row.appendChild(mini);
    return row;
  };

  state.orderedKeys.forEach((k, idx) => {
    const row = makeRow(k, idx);
    if (row) box.appendChild(row);
  });
}

function mergeVacuumAndSkips(events) {
  const out = [];
  for (const e of events) {
    if (e.type !== "vacuum") { out.push(e); continue; }
    const last = out[out.length - 1];
    if (last && last.type === "vacuum" && Math.abs(last.end - e.start) < 1e-9) {
      last.end = e.end;
      last.duration += e.duration;
    } else {
      out.push({...e});
    }
  }
  return out;
}

function annotateDeath(events, threshold) {
  const th = Number(threshold) || 0;
  if (!(th > 0)) return events.map(e => ({...e, death:false}));
  return events.map(e => {
    if (e.type !== "vacuum") return {...e, death:false};
    return {...e, death: (e.duration >= th)};
  });
}

function initCtx() {
  return { lastFeitian: null, feitianWindowEnd: null, lianxinUsed: false };
}
function isFeitian(n) { return n === "飞天"; }
function isLianxin(n) { return n === "飞天·莲心"; }
function isZhuyue(nm) {
  return nm === "逐月";
}
function isZhuyueChengfeng(nm) {
  // 与“逐月”是不同技能
  return nm === "逐月·乘风" || nm === "逐月乘风" || nm === "逐月.乘风" || nm === "逐月 乘风";
}
function isFuyangTaixu(nm) {
  return nm === "俯仰太虚";
}
function isFuyangTaixuLingyun(nm) {
  return nm === "俯仰太虚·灵韵" || nm === "俯仰太虚灵韵" || nm === "俯仰太虚.灵韵" || nm === "俯仰太虚 灵韵";
}

function prereqOk(skill, t, ctx, nextReady, zhuyueKey) {
  const nm = skill.name;

  // 飞天联动（仅针对：飞天·莲心、逐月·乘风）
  if (isLianxin(nm)) {
    if (ctx.lastFeitian === null) return false;
    if (ctx.feitianWindowEnd === null) return false;
    return (t <= ctx.feitianWindowEnd + 1e-9);
  }
  if (isZhuyueChengfeng(nm)) {
    if (ctx.lastFeitian === null) return false;
    if (ctx.feitianWindowEnd === null) return false;
    if (ctx.lianxinUsed) return false;
    return (t <= ctx.feitianWindowEnd + 1e-9);
  }

  // 俯仰太虚 / 俯仰太虚·灵韵：只能在“逐月”的冷却时间内触发
  if (isFuyangTaixu(nm) || isFuyangTaixuLingyun(nm)) {
    // 仅对妙音做逐月冷却窗口限制（其他职业数据未定义，默认不限制）
    if (state.prof !== "妙音") return true;
    if (!zhuyueKey) return false; // 未携带“逐月”则不可用（与“逐月·乘风”无关）
    const zyReady = (nextReady && nextReady[zhuyueKey] !== undefined) ? nextReady[zhuyueKey] : undefined;
    if (zyReady === undefined) return false; // 对应“逐月”技能从未释放过，则不处于冷却窗口
    return (zyReady > t + 1e-12); // 逐月未转好 => 逐月处于冷却中
  }

  return true;
}

function onCastUpdateCtx(skill, t, ctx) {
  const nm = skill.name;
  if (isFeitian(nm)) {
    ctx.lastFeitian = t;
    ctx.feitianWindowEnd = t + 20.0;
    ctx.lianxinUsed = false;
  } else if (isLianxin(nm)) {
    ctx.lianxinUsed = true;
  }
}

function countProfCooldown(nextReady, profKeys, t) {
  let c = 0;
  for (const k of profKeys) {
    const r = nextReady[k];
    if (r !== undefined && r > t + 1e-12) c++;
  }
  return c;
}

function applyWood3Proc(nextReady, profKeys, t) {
  for (const k of profKeys) {
    const r = nextReady[k];
    if (r === undefined) continue;
    if (r <= t + 1e-12) continue;
    const remaining = r - t;
    const reduce = Math.min(remaining * 0.4, 5.0);
    nextReady[k] = Math.max(t, r - reduce);
  }
}

function canTriggerWood3ByCast(skill) {
  return skill.source !== "内功";
}

function nextCastableTime(skill, t, ctx, nextReady, zhuyueKey) {
  if (!prereqOk(skill, t, ctx, nextReady, zhuyueKey)) return Infinity;
  return Math.max(t, (nextReady[skill.key] ?? 0));
}

function generateSchedule() {
  const T = Number(state.modeDuration);
  const order = state.orderedKeys.map(k => state.skillIndex.get(k)).filter(Boolean);
  if (!order.length || !(T > 0)) return [];

  const prof = state.prof;
  const wood = state.woodChoice;
  const mode = state.schedMode;

  const profKeys = order.filter(s=>s.source===prof).map(s=>s.key);

  const traps = order.filter(s => !((s.cast ?? 0) > 0) && !(effectiveCd(s, prof, wood) > 0));
  if (traps.length > 0) {
    alert("存在“霸体=0 且 有效冷却=0”的技能，会导致排轴无限循环：\n" + traps.map(s=>s.name + "（" + s.source + "）").join("\n") + "\n请补齐冷却或取消选择。");
    return [];
  }

  const nextReady = {};
  let wood3NextReady = 0;
  const WOOD3_ICD = 20.0;

  let t = 0;
  let idx = 0;
  const events = [];
  let guard = 0;

  let stagnantCount = 0;
  let lastT = t;

  const ctx = initCtx();
  // 用于“俯仰太虚/灵韵”前置判定：逐月（优先）/逐月（兜底）的 key（必须在本次选择中存在）
  const zhuyueKey = (function() {
    // 俯仰太虚联动：仅对“妙音”生效，且仅绑定“逐月”（与“逐月·乘风”是不同技能）
    if (prof !== "妙音") return null;
    for (const s of order) {
      if (s && s.name === "逐月") return s.key;
    }
    return null;
  })();


  function doCast(skill) {
    let cast = Number(skill.cast ?? 0);
    if (!(cast > 0)) cast = 0;
    const cdEff = effectiveCd(skill, prof, wood);

    let wood3Triggered = false;
    if (wood === 3 && canTriggerWood3ByCast(skill) && t + 1e-12 >= wood3NextReady) {
      const cnt = countProfCooldown(nextReady, profKeys, t);
      if (cnt >= 3) {
        applyWood3Proc(nextReady, profKeys, t);
        wood3NextReady = t + WOOD3_ICD;
        wood3Triggered = true;
      }
    }

    const end = Math.min(t + cast, T);
    events.push({
      type: "skill",
      key: skill.key,
      name: skill.name,
      source: skill.source,
      start: t,
      end: end,
      cast: cast,
      cd: cdEff,
      wood3Triggered: wood3Triggered
    });

    nextReady[skill.key] = t + cdEff;
    onCastUpdateCtx(skill, t, ctx);
    t += cast;
  }

  while (t < T - 1e-9 && guard < 300000) {
    guard++;

    if (mode === "strict") {
      const s = order[idx];

      if (!prereqOk(s, t, ctx, nextReady, zhuyueKey)) {
        events.push({
          type: "skip",
          start: t, end: t,
          name: s.name,
          source: s.source,
          reason: "前置条件不满足（飞天联动）"
        });
        idx = (idx + 1) % order.length;
        continue;
      }

      const ready = (nextReady[s.key] ?? 0);
      if (ready > t + 1e-12) {
        const endVac = Math.min(ready, T);
        events.push({ type:"vacuum", start:t, end:endVac, duration:endVac - t });
        t = ready;
        if (t >= T - 1e-9) break;
      }

      doCast(s);
      idx = (idx + 1) % order.length;

    } else {
      let found = -1;
      for (let off = 0; off < order.length; off++) {
        const s = order[(idx + off) % order.length];
        if (!prereqOk(s, t, ctx, nextReady, zhuyueKey)) continue;
        const ready = (nextReady[s.key] ?? 0);
        if (ready <= t + 1e-12) { found = off; break; }
      }

      if (found >= 0) {
        const s = order[(idx + found) % order.length];
        doCast(s);
        idx = (idx + found + 1) % order.length;
      } else {
        let nextT = Infinity;
        for (const s of order) {
          const nt = nextCastableTime(s, t, ctx, nextReady, zhuyueKey);
          if (nt < nextT) nextT = nt;
        }
        if (!isFinite(nextT) || nextT <= t + 1e-12) {
          events.push({ type:"vacuum", start:t, end:Math.min(T,t), duration:0, note:"动态排轴无法推进：当前无可施放技能（可能因飞天联动前置未满足且无飞天可施放）。" });
          break;
        }
        const endVac = Math.min(nextT, T);
        events.push({ type:"vacuum", start:t, end:endVac, duration:endVac - t });
        t = nextT;
      }
    }

    if (Math.abs(t - lastT) < 1e-12) stagnantCount++;
    else { stagnantCount = 0; lastT = t; }

    if (stagnantCount > order.length * 120) {
      events.push({ type:"vacuum", start:t, end:Math.min(T,t), duration:0, note:"检测到时间长期不推进（大量0秒占用/跳过循环）。请补齐“霸体时间”或调整排轴/前置条件。" });
      break;
    }
  }

  if (guard >= 300000) {
    events.push({ type:"vacuum", start:Math.min(t,T), end:T, duration:Math.max(0, T - t), note:"触发安全退出：事件数过多。" });
  }

  const merged = mergeVacuumAndSkips(events);
  return annotateDeath(merged, state.deathThreshold);
}

function isFilterNoCastOn() {
  const el = $("filterNoCast");
  return !!(el && el.checked);
}
function applyNoCastFilter(events) {
  if (!isFilterNoCastOn()) return {events: events, hidden: 0};
  let hidden = 0;
  const filtered = [];
  for (const e of events) {
    if (e.type === "skill" && !(e.cast > 0)) { hidden++; continue; }
    filtered.push(e);
  }
  return {events: filtered, hidden};
}

function renderResults(eventsAll) {
  const tbody = $("resultTable").querySelector("tbody");
  tbody.innerHTML = "";
  const filteredPack = applyNoCastFilter(eventsAll);
  const events = filteredPack.events;
  const hiddenNoCast = filteredPack.hidden;


  const T = Number(state.modeDuration);
  let vacuum=0, skillCount=0, deathCount=0, maxVac=0;
  let firstDeathStart=null;
  let wood3ProcCount=0;
  let skipCount=0;

  for (const e of eventsAll) {
    if (e.type === "vacuum") {
      vacuum += e.duration;
      maxVac = Math.max(maxVac, e.duration);
      if (e.death) {
        deathCount++;
        if (firstDeathStart === null || e.start < firstDeathStart) firstDeathStart = e.start;
      }
    } else if (e.type === "skill") {
      skillCount++;
      if (e.wood3Triggered) wood3ProcCount++;
    } else if (e.type === "skip") {
      skipCount++;
    }
  }

  const pct = T > 0 ? (vacuum / T * 100) : 0;
  const modeName = DB.modes.find(m=>m.id===state.modeId)?.name || state.modeId;

  const th = Number(state.deathThreshold) || 0;
  const deathLine = (th > 0)
    ? ` ｜ 死亡阈值：<b>${fmt(th)}s</b> ｜ 死亡真空段数：<b>${deathCount}</b>` + (deathCount ? `（首次：<b>${fmt(firstDeathStart)}s</b>）` : "")
    : ` ｜ 死亡阈值：<b>未启用</b>`;

  const woodChoice = state.woodChoice;
  const woodLine = (woodChoice === 0) ? ` ｜ 木周天：<b>未选择</b>` :
    ` ｜ 木周天：<b>${woodChoice}木</b>` + (woodChoice===3 ? `（特效触发：<b>${wood3ProcCount}</b> 次）` : "");

  const schedLine = state.schedMode === "dynamic" ? "动态" : "严格";

    const filterLine = isFilterNoCastOn() ? ` ｜ 已隐藏无霸体技能：<b>${fmt(hiddenNoCast)}</b> 条` : ``;

  $("summaryBox").innerHTML =
    `模式：<b>${modeName}</b> ｜ 时长：<b>${T}s</b> ｜ 排轴策略：<b>${schedLine}</b> ｜ 施放次数：<b>${skillCount}</b> ｜ 跳过次数：<b>${skipCount}</b> ｜ 真空总时长：<b>${fmt(vacuum)}s</b>（<b>${fmt(pct)}%</b>）${filterLine} ｜ 最大单段真空：<b>${fmt(maxVac)}s</b>${deathLine}${woodLine}<br/>` +
    `顺序（循环优先级）：<span class="mono">${state.orderedKeys.map(k=>state.skillIndex.get(k)?.name).filter(Boolean).join(" → ")}</span>`;

  for (const e of events) {
    const tr = document.createElement("tr");
    if (e.type === "vacuum") tr.className = e.death ? "vacuum death" : "vacuum";
    if (e.type === "skip") tr.className = "skip";

    const td1 = document.createElement("td");
    td1.className = "mono"; td1.textContent = fmt(e.start) + "s";

    const td2 = document.createElement("td");
    td2.className = "mono"; td2.textContent = fmt(e.end) + "s";

    const td3 = document.createElement("td");
    if (e.type === "vacuum") {
      const th = Number(state.deathThreshold) || 0;
      if (e.death) {
        td3.innerHTML = `<b>死亡真空</b> <span class="muted">（单段真空 ≥ ${fmt(th)}s）</span>` + (e.note ? `<br/><span class="muted">${e.note}</span>` : "");
      } else {
        td3.innerHTML = `<b>真空</b> <span class="muted">（无可施放技能）</span>` + (e.note ? `<br/><span class="muted">${e.note}</span>` : "");
      }
    } else if (e.type === "skip") {
      td3.innerHTML = `<b>跳过：${e.name}</b> <span class="muted">（${e.reason || "不可用"}）</span>`;
    } else {
      const woodTag = e.wood3Triggered ? ` <span class="badge blue">木周天触发</span>` : "";
      td3.innerHTML = `<b>${e.name}</b>${woodTag} <span class="muted">（起始秒：${Math.floor(e.start)}）</span>`;
    }

    const td4 = document.createElement("td");
    td4.textContent = (e.type === "skill" || e.type === "skip") ? e.source : "-";

    const td5 = document.createElement("td");
    td5.className = "mono";
    td5.textContent = e.type === "skill" ? fmt(e.cast) + "s" : (e.type === "vacuum" ? fmt(e.duration) + "s" : "0s");

    const td6 = document.createElement("td");
    td6.className = "mono";
    td6.textContent = e.type === "skill" ? fmt(e.cd) + "s" : "-";

    tr.appendChild(td1); tr.appendChild(td2); tr.appendChild(td3);
    tr.appendChild(td4); tr.appendChild(td5); tr.appendChild(td6);
    tbody.appendChild(tr);
  }
}

function buildPlainText(events) {
  const modeName = DB.modes.find(m=>m.id===state.modeId)?.name || state.modeId;
  const lines = [];
  lines.push(`模式：${modeName}（${state.modeDuration}s）`);
  lines.push(`排轴策略：${state.schedMode}`);
  lines.push(`顺序：${state.orderedKeys.map(k=>state.skillIndex.get(k)?.name).filter(Boolean).join(" -> ")}`);
  const wood = state.woodChoice;
  lines.push(`木周天：${wood===0 ? "未选择" : (wood + "木")}`);
  const th = Number(state.deathThreshold) || 0;
  lines.push(`真空死亡阈值：${th>0 ? (th + "s") : "未启用"}`);
  lines.push(`前置条件：飞天·莲心(飞天后20s内)；逐月(飞天后且莲心前)；内功不触发3木特效；莲步盈华与并蒂互斥`);
  lines.push("");
  for (const e of events) {
    if (e.type === "vacuum") {
      const tag = e.death ? "死亡真空" : "真空";
      lines.push(`[${fmt(e.start)}s - ${fmt(e.end)}s] ${tag}（${fmt(e.duration)}s）`);
    } else if (e.type === "skip") {
      lines.push(`[${fmt(e.start)}s] 跳过：${e.name}（${e.reason || "不可用"}）`);
    } else {
      const tag = e.wood3Triggered ? "（木周天触发）" : "";
      lines.push(`[${fmt(e.start)}s] 施放：${e.name}${tag}（来源：${e.source}，霸体：${fmt(e.cast)}s，有效冷却：${fmt(e.cd)}s）`);
    }
  }
  return lines.join("\n");
}

function exportCSV(events) {
  const rows = [["type","start_s","end_s","name","source","cast_or_vacuum_s","cooldown_s_effective","start_second_floor","death","wood_choice","wood3_triggered","sched_mode","note_or_reason"]];
  for (const e of events) {
    if (e.type === "vacuum") {
      rows.push(["vacuum", e.start, e.end, e.death ? "死亡真空" : "真空", "", e.duration, "", Math.floor(e.start), e.death ? 1 : 0, state.woodChoice, 0, state.schedMode, e.note || ""]);
    } else if (e.type === "skip") {
      rows.push(["skip", e.start, e.end, e.name, e.source, 0, "", Math.floor(e.start), 0, state.woodChoice, 0, state.schedMode, e.reason || ""]);
    } else {
      rows.push(["skill", e.start, e.end, e.name, e.source, e.cast, e.cd, Math.floor(e.start), 0, state.woodChoice, e.wood3Triggered ? 1 : 0, state.schedMode, ""]);
    }
  }
  const csv = rows.map(r => r.map(v => {
    const s = String(v ?? "");
    return (s.includes(",") || s.includes('"') || s.includes("\n")) ? ('"' + s.replace(/"/g,'""') + '"') : s;
  }).join(",")).join("\n");
  const blob = new Blob([csv], {type:"text/csv;charset=utf-8"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "逆水寒_排轴.csv";
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

function resetAll() {
  state.selectedKeys = new Set();
  state.orderedKeys = [];
  state.events = [];
  $("skillSearch").value = "";
  renderSkillPicker();
}

function init() {
  // Step5 过滤开关：隐藏无霸体技能
  const filterEl = $("filterNoCast");
  if (filterEl) {
    filterEl.addEventListener("change", ()=> {
      if (state.events && state.events.length) renderResults(state.events);
    });
  }

  renderModeOptions();
  renderProfOptions();

  document.querySelectorAll('input[name="wood"]').forEach(r => {
    r.addEventListener("change", ()=> {
      state.woodChoice = getWoodChoice();
      renderSkillPicker();
      if (!$("step4").classList.contains("hidden")) renderOrderList();
    });
  });

  document.querySelectorAll('input[name="sched"]').forEach(r => {
    r.addEventListener("change", ()=> {
      state.schedMode = getSchedMode();
    });
  });

  $("toStep2").addEventListener("click", ()=> {
    state.modeId = $("modeSelect").value;
    state.modeDuration = Number($("modeDuration").value) || 120;
    const th = Number($("deathThreshold").value);
    state.deathThreshold = (th >= 0) ? th : 0;
    setActiveStep(2);
  });

  $("back1").addEventListener("click", ()=> setActiveStep(1));

  $("toStep3").addEventListener("click", ()=> {
    state.prof = $("profSelect").value;
    state.woodChoice = getWoodChoice();
    renderSkillPicker();
    setActiveStep(3);
  });

  $("back2").addEventListener("click", ()=> setActiveStep(2));

  $("skillSearch").addEventListener("input", ()=> renderSkillPicker());

  $("selectAll").addEventListener("click", ()=> {
    const search = ($("skillSearch").value || "").trim().toLowerCase();
    const prof = state.prof;
    const wood = state.woodChoice;

    for (const s of state.skillIndex.values()) {
      const cast = (s.cast ?? 0);
      const effCd = effectiveCd(s, prof, wood);
      const willLoopTrap = (!(cast > 0)) && (!(effCd > 0));
      if (willLoopTrap) continue;
      if (search && !s.name.toLowerCase().includes(search)) continue;
      state.selectedKeys.add(s.key);
    }
    enforceMutualExclusion();
    renderSkillPicker();
  });

  $("clearAll").addEventListener("click", ()=> {
    state.selectedKeys.clear();
    state.orderedKeys = [];
    // 清空后仍保留妙音必带
    enforceRequiredSkills();
    renderSkillPicker();
  });

  $("toStep4").addEventListener("click", ()=> {
    state.skillIndex = buildSkillIndex(state.prof);
    // 进入排序前再次确保妙音必带已加入选择
    enforceRequiredSkills();
    collectOrderedFromSelected();
    renderOrderList();
    setActiveStep(4);
  });

  $("back3").addEventListener("click", ()=> setActiveStep(3));

  $("calc").addEventListener("click", ()=> {
    // 生成前再次确保妙音必带存在
    enforceRequiredSkills();
    collectOrderedFromSelected();
    if (!state.orderedKeys.length) { renderOrderList(); return; }
    state.modeDuration = Number($("modeDuration").value) || state.modeDuration || 120;
    const th = Number($("deathThreshold").value);
    state.deathThreshold = (th >= 0) ? th : 0;
    state.woodChoice = getWoodChoice();
    state.schedMode = getSchedMode();

    state.events = generateSchedule();
    if (!state.events.length) return;
    renderResults(state.events);
    setActiveStep(5);
  });

  $("copyText").addEventListener("click", async ()=> {
    const text = buildPlainText(applyNoCastFilter(state.events || []).events);
    try {
      await navigator.clipboard.writeText(text);
      alert("已复制到剪贴板");
    } catch {
      const ta = document.createElement("textarea");
      ta.value = text;
      document.body.appendChild(ta);
      ta.select();
      document.execCommand("copy");
      ta.remove();
      alert("已复制到剪贴板（兼容模式）");
    }
  });

  $("exportCsv").addEventListener("click", ()=> exportCSV(applyNoCastFilter(state.events || []).events));

  $("restart").addEventListener("click", ()=> {
    setActiveStep(1);
    resetAll();
  });

  state.prof = $("profSelect").value;
  state.skillIndex = buildSkillIndex(state.prof);
  state.woodChoice = getWoodChoice();
  state.schedMode = getSchedMode();
  renderSkillPicker();
}

init();
</script>
</body>
</html>
